#!/usr/bin/env python3
import platform
import sys
import os
from pathlib import Path
import venv
from shutil import which
import subprocess
import contextlib
from tempfile import TemporaryDirectory
from contextlib import ExitStack
from datetime import datetime
import urllib.request
import tarfile

DNF_PACKAGES = [
    "",
    "git",
    "gcc",
    "debootstrap",
    "systemd-devel",
    "systemd-container",
    "mkosi",
    "fakeroot",
    "fakechroot",
    "vim",
    "tmux",
    "links",
    "nginx",
    "strace",
    "bcc-tools",
    "bpftrace",
    "python3-bcc",
    "procps",
    "passwd",
    "lsof",
    "xq",
    "wireshark-cli",
    "util-linux-user",
    "iputils",
    "htop",
    "stress",
    "bash-completion",
    "python3-devel",
    "python3-Cython",
    "python3-wheel",
    "python3-ipython",
    "systemtap",
    "systemtap-sdt-devel",
    "python3-dnslib",
    "python3-cachetools",
    "readline-devel",
]


THIS_DIR = Path(__file__).absolute().resolve().parent
BUILD_DIR = THIS_DIR / "build"
VENV = THIS_DIR / "venv"
PYTHON = VENV / "bin/python3"
SUDO = "/usr/bin/sudo"
CONF_DIR = THIS_DIR / "conf"
WORKSHOP = THIS_DIR / "workshop"

DEFAULT_CONTAINER_BASE = "registry.fedoraproject.org/fedora:39"
DEFAULT_CONTAINER_IMAGE_NAME = "localhost/systemd-workshop"

# DEFAULT_VAGRANT_IMAGE = "fedora/39-cloud-base"
DEFAULT_VAGRANT_IMAGE = "generic/fedora39"
DEFAULT_VAGRANT_STAGE_0 = "fedora/39-base.box"
DEFAULT_VAGRANT_STAGE_N_PREFIX = "fedora/37-workshop-"
DEFAULT_VAGRANT_LAST = "fedora/37-last.box"


def reexec(python=PYTHON, sudo=False):
    binary = SUDO if sudo else python
    ecmd = (python, *sys.argv)
    if sudo:
        ecmd = (SUDO, *ecmd)
    os.execv(binary, ecmd)


def asroot():
    if os.getuid() != 0:
        reexec(sudo=True)


if not VENV.exists():
    venv.create(
        VENV,
        system_site_packages=False,
        clear=True,
        symlinks=True,
        with_pip=True,
        prompt=None,
        # upgrade_deps=False
    )

if not Path(sys.executable).samefile(PYTHON):
    # re exec but in the venv
    reexec()

try:
    import click
    import jinja2
except ImportError:
    subprocess.run(
        [sys.executable, "-m", "pip", "install", "click", "jinja2"], check=True
    )
    reexec()


BOX_DIR = Path(__file__).resolve().absolute().parent / "boxes"
BIN_DIR = Path(__file__).resolve().absolute().parent / "bin"
WORKSHOP_DIR = Path(__file__).resolve().absolute().parent / "workshop"


class Vagrant:
    def __init__(self, base, base_box):
        self.base = Path(base)
        self.vagrant_file = f"""

Vagrant.configure("2") do |config|

  config.vm.box = "{base_box}"
  config.vm.box_check_update = false

  config.vm.provider "virtualbox" do |vb|
     vb.memory = "1024"
  end

  
end

"""

    def _vagrant_call(self, cmd, *args, **kwargs):
        subprocess.check_call(["vagrant", cmd, *args], cwd=self.base, **kwargs)

    def ssh(self, *args):
        self._vagrant_call("ssh", *args)

    def shell(self):
        self._vagrant_call("ssh")

    def run(self, script):
        import base64

        s = base64.encodebytes(script.encode()).decode().replace("\n", "").rstrip()
        cmd = f"echo {s} | base64 --decode - | sudo bash"
        self._vagrant_call("ssh", "--", cmd)

    def halt(self):
        self._vagrant_call("halt")

    def up(self):
        self._vagrant_call("up")

    def destroy(self):
        self._vagrant_call("destroy", "--force")

    def package(self, pkg):
        self._vagrant_call("package", "--output", pkg)

    def __enter__(self):
        (self.base / "Vagrantfile").write_text(self.vagrant_file)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.destroy()


@click.group()
def main():
    ...


@main.group()
def container():
    ...


class Container:
    def __init__(self, image_name):
        self.image_name = image_name
        self.tdir = TemporaryDirectory()
        self.container_name = f"{Path(self.tdir.name).name}"

    def __run(self, *args, **kwargs):
        cmd = [which("podman") or "podmand", *args]
        line = subprocess.list2cmdline(cmd)
        print(f"executing '{line}'")
        subprocess.run(line, **{**kwargs, "check": True, "shell": True})

    def run(self):
        kernel_version = platform.release()
        self.__run(
            "container",
            "run",
            "-d",
            *("--network", "host"),
            "--privileged",
            *("-v", f"{THIS_DIR / 'workshop'}:/usr/local/src/workshop/workshop"),
            # eBPF stuff
            *("-v", "/sys/kernel/debug:/sys/kernel/debug"),
            *("-v", "/sys/kernel/tracing:/sys/kernel/tracing"),
            *("-v", "/sys/fs/cgroup:/sys/fs/cgroup"),
            *("-v", "/sys/fs/bpf:/sys/fs/bpf"),
            # this 2 mounts shoud, be smarters
            *(
                "-v",
                f"/usr/lib/modules/{kernel_version}/build:/usr/src/kernels/{kernel_version}:ro",
            ),
            *(
                "-v",
                f"/usr/lib/modules/{kernel_version}:/lib/modules/{kernel_version}:ro",
            ),
            "--name",
            self.container_name,
            self.image_name,
        )

    def rm(self):
        self.__run(
            "container",
            "rm",
            "--force",
            "--ignore",
            self.container_name,
        )

    def shell(self, shell="/bin/bash"):
        self.__run(
            "container",
            "exec",
            "-ti",
            self.container_name,
            "systemd-run",
            *("--working-directory", "/usr/local/src/workshop/workshop"),
            "--tty",
            shell,
        )

    def __enter__(self):
        self.run()
        while True:
            with contextlib.suppress(Exception):
                self.shell("/bin/true")
                break

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.rm()


@container.command()
@click.option(
    "--as-root/--not-as-root",
    default=platform.system() not in ("Darwin",),
    help=(
        "If we should run podmand as root, a.k.a. if we should rexec as sudo. "
        "On macOS, is not necessary to run as root, because we run inside a vm."
    ),
)
def run(as_root: bool) -> None:
    if as_root:
        asroot()
    with Container(f"{DEFAULT_CONTAINER_IMAGE_NAME}:latest") as c:
        try:
            c.shell()
        except subprocess.CalledProcessError as e:
            sys.exit(e.returncode)


@container.command()
@click.option("--base", default=DEFAULT_CONTAINER_BASE, show_default=True)
@click.option("--image-name", default=DEFAULT_CONTAINER_IMAGE_NAME, show_default=True)
@click.option(
    "--as-root/--not-as-root",
    default=platform.system() not in ("Darwin",),
    help=(
        "If we should run podmand as root, a.k.a. if we should rexec as sudo. "
        "On macOS, is not necessary to run as root, because we run inside a vm."
    ),
)
@click.option("--run-after/--no-run-after", default=False)
def build(base, image_name, as_root, run_after):
    if as_root:
        asroot()

    pip_packages = [
        "",
        "pystemd",
        "climage",
    ]
    CONTAINER_FILE_CONTENT = jinja2.Template(
        """
FROM {{ base }}
RUN dnf list
RUN dnf install -y gcc
RUN dnf install -y systemtap-sdt-devel
RUN dnf install -y readline-devel
RUN dnf install -y openssl-devel
RUN dnf install -y zlib-devel
RUN dnf install -y libffi-devel
RUN dnf install -y g++
RUN dnf install -y libuuid-devel
RUN dnf install -y {{ dnf_packages }}

# install python
RUN python3 -m pip install {{ pip_packages }}

# change root password
RUN echo workshop | passwd --stdin root

# install a python compiled with dtrace
# this should go to its own recipe, so we just pull a package

ADD build/cpython/dist/py.tgz /opt/cpython/py.tgz
RUN cd /opt/cpython/ && tar xzf py.tgz

### END

# add debian home
# RUN fakeroot debootstrap --include 'dbus,vim' unstable /opt/debian

# create a few dirs
RUN mkdir -p /usr/local/src/workshop

## Now we copy files from demo to the container

# copy all files in container
COPY . /usr/local/src/workshop

#copy profile.d files
COPY {% for conf in profile_d -%} {{ conf }} {% endfor -%} /etc/profile.d/

# copy systemd units
COPY {% for unit in systemd_units -%} {{ unit }} {% endfor -%} /etc/systemd/system/

# root files
COPY {% for conf in root_conf -%} {{ conf }} {% endfor -%} /root/

# selinux
COPY {{ selinux_config }}  /etc/selinux/config 

ENV WORKSHOP_DIR=/usr/local/src/workshop/workshop

WORKDIR /usr/local/src/workshop

RUN dnf clean all

# starts systemd
CMD [ "/usr/sbin/init" ]

        """
    ).render(
        base=base,
        dnf_packages="\\\n  ".join(DNF_PACKAGES),
        pip_packages="\\\n  ".join(pip_packages),
        profile_d=[conf.relative_to(THIS_DIR) for conf in CONF_DIR.glob("profile.d/*")],
        selinux_config=(CONF_DIR / "workshop-selinux-config").relative_to(THIS_DIR),
        systemd_units=[
            unit.relative_to(THIS_DIR) for unit in WORKSHOP.glob("**/systemd.units/*")
        ],
        root_conf=[
            conf.relative_to(THIS_DIR) for conf in (CONF_DIR / "home").iterdir()
        ],
    )
    print(CONTAINER_FILE_CONTENT)
    (THIS_DIR / "Containerfile").write_text(CONTAINER_FILE_CONTENT)

    subprocess.run(
        [which("podman"), "build", "--rm", "-t", f"{image_name}:latest", "."]
    )

    if run_after:
        # TODO: replace this with just invoke run
        with Container(f"{DEFAULT_CONTAINER_IMAGE_NAME}:latest") as c:
            try:
                c.shell()
            except subprocess.CalledProcessError as e:
                sys.exit(e.returncode)


@main.command()
@click.option("--build-dir", default=None, help="where to build the box")
@click.option(
    "--keep-vm/--destroy-vm",
    default=False,
    help="if you want to destroy the vm after building",
    show_default=True,
)
@click.option(
    "--build-stage", "-m", type=click.Choice(["0", "1", "n", "i", "l"]), default="n"
)
@click.option(
    "--provision-script",
    type=Path,
    default=BIN_DIR / "provision-build",
    show_default=True,
)
@click.option(
    "--pre-provision-shell",
    is_flag=True,
    default=False,
    show_default=True,
)
@click.option(
    "--post-provision-shell",
    is_flag=True,
    default=False,
    show_default=True,
)
def build(
    build_dir,
    keep_vm,
    build_stage,
    provision_script,
    pre_provision_shell,
    post_provision_shell,
):
    if build_stage == "0":
        base_box = DEFAULT_VAGRANT_IMAGE
        dest_box = BOX_DIR / DEFAULT_VAGRANT_STAGE_0
        if dest_box.exists():
            raise FileExistsError("{dest_box} exists, please delete it or start from 1")
        alias_box = None
    elif build_stage == "1":
        base_box = BOX_DIR / DEFAULT_VAGRANT_STAGE_0
        dest_box = (
            BOX_DIR
            / f"{DEFAULT_VAGRANT_STAGE_N_PREFIX}{datetime.today().strftime('%Y.%m.%d.%H%M')}.box"
        )
        alias_box = BOX_DIR / DEFAULT_VAGRANT_LAST
    elif build_stage in ("n", "l"):
        base_box = (BOX_DIR / DEFAULT_VAGRANT_LAST).resolve()
        dest_box = (
            BOX_DIR
            / f"{DEFAULT_VAGRANT_STAGE_N_PREFIX}{datetime.today().strftime('%Y.%m.%d.%H%M')}.box"
        )
        alias_box = BOX_DIR / DEFAULT_VAGRANT_LAST
    elif build_stage in "l":
        base_box = (BOX_DIR / DEFAULT_VAGRANT_LAST).resolve()
        dest_box = None
        alias_box = None
    elif build_stage == "i":
        base_box = DEFAULT_VAGRANT_LAST
        dest_box = (
            BOX_DIR
            / f"{DEFAULT_VAGRANT_STAGE_N_PREFIX}{datetime.today().strftime('%Y.%m.%d.%H%M')}.box"
        )
        alias_box = BOX_DIR / DEFAULT_VAGRANT_LAST
    elif build_stage == "c":
        raise NotImplementedError("not implemented... yet!")

    with ExitStack() as estack:
        if not build_dir:
            build_dir = estack.enter_context(TemporaryDirectory())

        if not keep_vm:
            box = estack.enter_context(Vagrant(build_dir, base_box))
        else:
            box = Vagrant(build_dir, base_box).__enter__()

        box.up()

        if pre_provision_shell:
            with contextlib.suppress():
                box.shell()

        if provision_script:
            try:
                print(f"executing {provision_script=}")
                box.run(Path(provision_script).read_text())
            except:
                with contextlib.suppress():
                    box.shell()

        if post_provision_shell:
            with contextlib.suppress():
                box.shell()
        if dest_box:
            box.package(dest_box.absolute())
        if alias_box:
            if alias_box.exists():
                alias_box.unlink()
            alias_box.symlink_to(dest_box.absolute())


@main.command()
@click.option("--build-root", default=BUILD_DIR / "cpython", type=Path)
@click.option(
    "--cpython-url",
    default="https://www.python.org/ftp/python/3.12.2/Python-3.12.2.tgz",
)
def build_python(build_root: Path, cpython_url: str):
    dist_dir = build_root / "dist"
    container_dir = build_root / "container"
    container_file = container_dir / "Containerfile"

    build_script = build_root / "build-python"

    build_root.mkdir(parents=True, exist_ok=True)
    container_dir.mkdir(parents=True, exist_ok=True)
    dist_dir.mkdir(parents=True, exist_ok=True)

    CONTAINER_INSTALL_PREFIX = "/opt/cpython"
    BASE_NAME = "localhost/python-build:latest"
    container_file.write_text(
        f"""
FROM {DEFAULT_CONTAINER_BASE}

ENV INSTALL_PREFIX={CONTAINER_INSTALL_PREFIX}

RUN dnf list
ADD {cpython_url} /usr/local/src/
RUN cd /usr/local/src/ && tar xzf  *.tgz

RUN dnf install -y gcc
RUN dnf install -y systemtap-sdt-devel
RUN dnf install -y readline-devel
RUN dnf install -y openssl-devel
RUN dnf install -y zlib-devel
RUN dnf install -y libffi-devel
RUN dnf install -y g++
RUN dnf install -y libuuid-devel

RUN cd /usr/local/src/Python-3.12.2 && \\
    ./configure \\
        --with-dtrace \\
        --with-readline \\
        --disable-shared \\
        --enable-loadable-sqlite-extensions \\
        --prefix $INSTALL_PREFIX 

RUN cd /usr/local/src/Python-3.12.2 && make

RUN cd /usr/local/src/Python-3.12.2 && make install
RUN mkdir $INSTALL_PREFIX/logs
RUN cp /usr/local/src/Python-3.12.2/configure.ac /usr/local/src/Python-3.12.2/config.log $INSTALL_PREFIX/logs
        """
    )

    build_script.write_text(
        """#!/bin/bash
set -ex

echo "hi! installing $PYTHON_SRC"

ls /usr/local/src/
cd $PYTHON_SRC
make

cd $INSTALL_PREFIX
tar czf py.tgz *
cp py.tgz $PYTHON_DIST

    """
    )
    build_script.chmod(0o755)

    subprocess.run(
        ["podman", "build", *("--network", "host"), *("-t", BASE_NAME),"."],
        cwd=container_dir,
        text=True,
        check=True,
    )

    subprocess.run(
        [
            "podman",
            "run",
            "--rm",
            *("--network", "host"),
            *("-v", f"{build_script}:/usr/local/bin/build-python"),
            *("-v", f"{dist_dir}:/opt/dist"),
            *("-e", "PYTHON_SRC=/usr/local/src/Python-3.12.2"),
            # *("-e", "INSTALL_PREFIX=/opt/cpython"),
            *("-e", "PYTHON_DIST=/opt/dist"),
            BASE_NAME,
            "/usr/local/bin/build-python",
        ]
    )


@main.command()
def lint():
    subprocess.run(
        [
            "black",
            ".",
            THIS_DIR / "workshopctl",
            THIS_DIR / "bin" / "pystemd-shell",
            THIS_DIR / "bin" / "provision-host",
        ]
    )


if __name__ == "__main__":
    main()
